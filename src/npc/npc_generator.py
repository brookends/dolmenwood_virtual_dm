"""
NPC Generator for Dolmenwood Virtual DM.

Generates complete NPC characters from simple descriptions like "level 7 Cleric"
with full access to class abilities, spell slots, and combat capabilities.

NPCs generated by this system can be directly used in combat encounters.
"""

import logging
import uuid
from dataclasses import dataclass
from enum import Enum
from typing import Any, Optional

from src.data_models import (
    CharacterState,
    DiceRoller,
    SpellSlotState,
    ClassSpecificData,
    ArmorWeight,
    EncumbranceSystem,
)
from src.classes.class_manager import get_class_manager
from src.classes.class_data import ClassDefinition, HitDie, MagicType
from src.kindred.kindred_manager import get_kindred_manager
from src.kindred.kindred_data import KindredDefinition

logger = logging.getLogger(__name__)


class AbilityScoreMethod(str, Enum):
    """Methods for generating NPC ability scores."""

    STANDARD_ARRAY = "standard_array"  # Use 15, 14, 13, 12, 10, 8
    ROLL_3D6 = "roll_3d6"  # Roll 3d6 in order
    ROLL_4D6_DROP = "roll_4d6_drop"  # Roll 4d6, drop lowest, arrange
    POINT_BUY = "point_buy"  # All 10s (balanced average)
    HEROIC = "heroic"  # 16, 15, 14, 13, 12, 11 (strong NPCs)
    ELITE = "elite"  # 18, 16, 14, 12, 10, 8 (boss-level)


# Standard ability score arrays
ABILITY_ARRAYS = {
    AbilityScoreMethod.STANDARD_ARRAY: [15, 14, 13, 12, 10, 8],
    AbilityScoreMethod.POINT_BUY: [10, 10, 10, 10, 10, 10],
    AbilityScoreMethod.HEROIC: [16, 15, 14, 13, 12, 11],
    AbilityScoreMethod.ELITE: [18, 16, 14, 12, 10, 8],
}

# Ability score priority by class (prime ability first)
CLASS_ABILITY_PRIORITY = {
    "fighter": ["STR", "CON", "DEX", "WIS", "CHA", "INT"],
    "thief": ["DEX", "INT", "CHA", "CON", "WIS", "STR"],
    "magician": ["INT", "DEX", "CON", "WIS", "CHA", "STR"],
    "cleric": ["WIS", "CON", "STR", "CHA", "DEX", "INT"],
    "friar": ["WIS", "CON", "CHA", "STR", "DEX", "INT"],
    "knight": ["STR", "CON", "CHA", "DEX", "WIS", "INT"],
    "hunter": ["DEX", "WIS", "CON", "STR", "INT", "CHA"],
    "bard": ["CHA", "DEX", "INT", "WIS", "CON", "STR"],
    "enchanter": ["CHA", "INT", "DEX", "WIS", "CON", "STR"],
}

# Default priority if class not in list
DEFAULT_ABILITY_PRIORITY = ["CON", "DEX", "STR", "WIS", "INT", "CHA"]


@dataclass
class NPCGenerationResult:
    """Result of NPC generation with the character and generation metadata."""

    character: CharacterState
    success: bool
    errors: list[str]
    warnings: list[str]
    generation_details: dict[str, Any]

    def __bool__(self) -> bool:
        return self.success


class NPCGenerator:
    """
    Generates complete NPC characters suitable for combat encounters.

    Usage:
        generator = NPCGenerator()

        # Generate a level 7 human cleric
        result = generator.generate(
            class_id="cleric",
            level=7,
            kindred_id="human",
            name="Brother Marcus"
        )

        if result.success:
            npc = result.character
            # npc is now a full CharacterState ready for combat
    """

    def __init__(self):
        """Initialize the NPC generator."""
        self.class_manager = get_class_manager()
        self.kindred_manager = get_kindred_manager()

    def generate(
        self,
        class_id: str,
        level: int,
        kindred_id: str = "human",
        name: Optional[str] = None,
        ability_scores: Optional[dict[str, int]] = None,
        ability_method: AbilityScoreMethod = AbilityScoreMethod.STANDARD_ARRAY,
        gender: Optional[str] = None,
        hp_method: str = "average",  # "average", "roll", "max"
        equipment_level: str = "typical",  # "none", "basic", "typical", "well-equipped"
        is_retainer: bool = False,
        employer_id: Optional[str] = None,
        extra_data: Optional[dict[str, Any]] = None,
    ) -> NPCGenerationResult:
        """
        Generate a complete NPC character.

        Args:
            class_id: Character class (e.g., "cleric", "fighter", "magician")
            level: Character level (1-15)
            kindred_id: Race/kindred (e.g., "human", "elf", "breggle")
            name: Character name (auto-generated if None)
            ability_scores: Pre-set ability scores {STR: 14, DEX: 12, ...}
            ability_method: Method for generating ability scores
            gender: "male", "female", or None (random)
            hp_method: How to determine HP ("average", "roll", "max")
            equipment_level: Starting equipment tier
            is_retainer: Whether this NPC is a retainer
            employer_id: ID of employer if retainer
            extra_data: Additional class-specific data

        Returns:
            NPCGenerationResult with the generated character
        """
        errors = []
        warnings = []
        details: dict[str, Any] = {
            "class_id": class_id,
            "level": level,
            "kindred_id": kindred_id,
            "ability_method": (
                ability_method.value
                if isinstance(ability_method, AbilityScoreMethod)
                else ability_method
            ),
            "hp_method": hp_method,
        }

        # Validate level
        if level < 1 or level > 15:
            errors.append(f"Invalid level {level}: must be 1-15")
            return NPCGenerationResult(
                character=None,  # type: ignore
                success=False,
                errors=errors,
                warnings=warnings,
                generation_details=details,
            )

        # Get class definition
        class_def = self.class_manager.get(class_id)
        if not class_def:
            errors.append(f"Unknown class: {class_id}")
            available = self.class_manager.get_all_ids()
            errors.append(f"Available classes: {', '.join(available)}")
            return NPCGenerationResult(
                character=None,  # type: ignore
                success=False,
                errors=errors,
                warnings=warnings,
                generation_details=details,
            )

        # Get kindred definition
        kindred_def = self.kindred_manager.get(kindred_id)
        if not kindred_def:
            warnings.append(f"Unknown kindred '{kindred_id}', using human")
            kindred_id = "human"
            kindred_def = self.kindred_manager.get("human")

        # Check kindred/class compatibility
        if not class_def.can_be_kindred(kindred_id):
            errors.append(f"{kindred_id.capitalize()} cannot be a {class_def.name}")
            return NPCGenerationResult(
                character=None,  # type: ignore
                success=False,
                errors=errors,
                warnings=warnings,
                generation_details=details,
            )

        # Generate or validate ability scores
        if ability_scores:
            final_abilities = self._validate_ability_scores(ability_scores, errors)
            details["ability_source"] = "provided"
        else:
            final_abilities = self._generate_ability_scores(ability_method, class_id)
            details["ability_source"] = ability_method.value

        if not final_abilities:
            return NPCGenerationResult(
                character=None,  # type: ignore
                success=False,
                errors=errors,
                warnings=warnings,
                generation_details=details,
            )

        details["ability_scores"] = final_abilities.copy()

        # Determine gender if not specified
        if gender is None:
            gender = DiceRoller.choice(["male", "female"], "NPC gender")
        details["gender"] = gender

        # Generate name if not provided
        if name is None:
            name = self._generate_name(kindred_def, gender)
        details["name"] = name

        # Calculate HP
        hp_max = self._calculate_hp(class_def, level, final_abilities.get("CON", 10), hp_method)
        details["hp_max"] = hp_max
        details["hp_rolls"] = []  # Could track individual rolls if hp_method == "roll"

        # Calculate base AC (no equipment for now)
        base_ac = 10 + self._get_ability_modifier(final_abilities.get("DEX", 10))

        # Generate a unique character ID
        character_id = f"npc_{class_id}_{str(uuid.uuid4())[:8]}"

        # Create the character
        character = CharacterState(
            character_id=character_id,
            name=name,
            character_class=class_id,
            level=level,
            ability_scores=final_abilities,
            hp_current=hp_max,
            hp_max=hp_max,
            armor_class=base_ac,
            base_speed=40,  # Standard human base Speed (p146)
            kindred=kindred_id,
            gender=gender,
            is_retainer=is_retainer,
            employer_id=employer_id,
            encumbrance_system=EncumbranceSystem.BASIC_WEIGHT,
            armor_weight=ArmorWeight.UNARMOURED,
        )

        # Initialize class data (saves, abilities, spell slots)
        self.class_manager.initialize_character_class_data(character, class_id, level)

        # Apply kindred abilities
        if kindred_def:
            character.kindred_abilities = [
                ability.ability_id
                for ability in self.kindred_manager.get_abilities_for_level(kindred_id, level)
            ]

        # Set up class-specific data
        if extra_data:
            if character.class_data is None:
                character.class_data = ClassSpecificData()
            self._apply_extra_data(character, extra_data)

        # Generate retainer morale if applicable
        if is_retainer:
            cha_mod = self._get_ability_modifier(final_abilities.get("CHA", 10))
            base_morale = 7  # Base morale for retainers
            character.morale = max(2, min(12, base_morale + cha_mod))

        details["class_abilities"] = character.class_abilities.copy()
        details["kindred_abilities"] = character.kindred_abilities.copy()
        details["saving_throws"] = character.saving_throws.copy()
        details["attack_bonus"] = character.attack_bonus

        if character.spell_slots:
            details["spell_slots"] = character.spell_slots.max_slots.copy()

        logger.info(
            f"Generated NPC: {name} (Level {level} {kindred_id.capitalize()} {class_def.name})"
        )

        return NPCGenerationResult(
            character=character,
            success=True,
            errors=errors,
            warnings=warnings,
            generation_details=details,
        )

    def generate_from_description(self, description: str, **kwargs) -> NPCGenerationResult:
        """
        Generate an NPC from a text description.

        Parses descriptions like:
        - "level 7 Cleric"
        - "Level 5 Human Fighter"
        - "Elf Magician level 10"
        - "Level 3 Breggle Hunter"

        Args:
            description: Text description of the NPC
            **kwargs: Additional arguments passed to generate()

        Returns:
            NPCGenerationResult
        """
        # Parse the description
        parsed = self._parse_description(description)

        if "error" in parsed:
            return NPCGenerationResult(
                character=None,  # type: ignore
                success=False,
                errors=[parsed["error"]],
                warnings=[],
                generation_details={"description": description},
            )

        # Merge parsed values with kwargs (kwargs take precedence)
        final_kwargs = {
            "class_id": parsed["class_id"],
            "level": parsed["level"],
            "kindred_id": parsed.get("kindred_id", "human"),
        }
        final_kwargs.update(kwargs)

        return self.generate(**final_kwargs)

    def _parse_description(self, description: str) -> dict[str, Any]:
        """
        Parse a text description into generation parameters.

        Args:
            description: Text like "level 7 Cleric" or "Human Fighter level 5"

        Returns:
            Dict with class_id, level, kindred_id, or error
        """
        import re

        description = description.strip().lower()
        result: dict[str, Any] = {}

        # Extract level (required)
        level_match = re.search(r"level\s*(\d+)", description)
        if level_match:
            result["level"] = int(level_match.group(1))
        else:
            # Try alternative patterns like "7th level" or just a number
            level_match = re.search(r"(\d+)(?:st|nd|rd|th)?\s*level", description)
            if level_match:
                result["level"] = int(level_match.group(1))
            else:
                return {"error": f"Could not determine level from: {description}"}

        # Get list of valid classes and kindreds
        valid_classes = self.class_manager.get_all_ids()
        valid_kindreds = self.kindred_manager.get_all_ids()

        # Find class (required)
        found_class = None
        for class_id in valid_classes:
            if class_id in description:
                found_class = class_id
                break

        if not found_class:
            return {
                "error": f"Could not determine class from: {description}. "
                f"Valid classes: {', '.join(valid_classes)}"
            }

        result["class_id"] = found_class

        # Find kindred (optional, defaults to human)
        for kindred_id in valid_kindreds:
            if kindred_id in description:
                result["kindred_id"] = kindred_id
                break
        else:
            result["kindred_id"] = "human"

        return result

    def _generate_ability_scores(self, method: AbilityScoreMethod, class_id: str) -> dict[str, int]:
        """Generate ability scores using the specified method."""
        abilities = ["STR", "DEX", "CON", "INT", "WIS", "CHA"]

        if method in ABILITY_ARRAYS:
            # Use a predefined array, arranged by class priority
            array = list(ABILITY_ARRAYS[method])
            priority = CLASS_ABILITY_PRIORITY.get(class_id.lower(), DEFAULT_ABILITY_PRIORITY)

            return {priority[i]: array[i] for i in range(6)}

        elif method == AbilityScoreMethod.ROLL_3D6:
            # Roll 3d6 in order (classic style)
            scores = {}
            for ability in abilities:
                roll = DiceRoller.roll("3d6", f"NPC {ability}")
                scores[ability] = roll.total
            return scores

        elif method == AbilityScoreMethod.ROLL_4D6_DROP:
            # Roll 4d6, drop lowest, arrange by priority
            rolled = []
            for _ in range(6):
                # Roll 4d6
                roll_result = DiceRoller.roll("4d6", "NPC ability (4d6 drop lowest)")
                dice = sorted(roll_result.rolls)
                total = sum(dice[1:])  # Sum top 3
                rolled.append(total)

            # Sort descending and arrange by class priority
            rolled.sort(reverse=True)
            priority = CLASS_ABILITY_PRIORITY.get(class_id.lower(), DEFAULT_ABILITY_PRIORITY)

            return {priority[i]: rolled[i] for i in range(6)}

        else:
            # Default to standard array
            return self._generate_ability_scores(AbilityScoreMethod.STANDARD_ARRAY, class_id)

    def _validate_ability_scores(
        self, scores: dict[str, int], errors: list[str]
    ) -> Optional[dict[str, int]]:
        """Validate provided ability scores."""
        required = {"STR", "DEX", "CON", "INT", "WIS", "CHA"}
        provided = {k.upper() for k in scores.keys()}

        missing = required - provided
        if missing:
            errors.append(f"Missing ability scores: {', '.join(missing)}")
            return None

        # Normalize to uppercase
        normalized = {k.upper(): v for k, v in scores.items()}

        # Validate ranges
        for ability, value in normalized.items():
            if not (3 <= value <= 18):
                errors.append(f"Invalid {ability} score {value}: must be 3-18")
                return None

        return normalized

    def _calculate_hp(
        self, class_def: ClassDefinition, level: int, con_score: int, method: str
    ) -> int:
        """Calculate HP for the NPC."""
        con_mod = self._get_ability_modifier(con_score)

        # Determine hit die size
        die_size = {
            HitDie.D4: 4,
            HitDie.D6: 6,
            HitDie.D8: 8,
        }.get(class_def.hit_die, 6)

        total_hp = 0

        for lvl in range(1, level + 1):
            if method == "max":
                # Maximum HP per die
                hp_roll = die_size
            elif method == "roll":
                # Roll the die
                hp_roll = DiceRoller.randint(1, die_size, f"NPC HP roll (d{die_size})")
            else:  # "average"
                # Average (round up for odd levels, down for even)
                hp_roll = (die_size // 2) + 1 if lvl % 2 == 1 else die_size // 2

            # Add CON modifier
            level_hp = max(1, hp_roll + con_mod)  # Minimum 1 HP per level
            total_hp += level_hp

        return max(1, total_hp)

    def _get_ability_modifier(self, score: int) -> int:
        """Get B/X-style ability modifier."""
        if score <= 3:
            return -3
        elif score <= 5:
            return -2
        elif score <= 8:
            return -1
        elif score <= 12:
            return 0
        elif score <= 15:
            return 1
        elif score <= 17:
            return 2
        else:
            return 3

    def _generate_name(self, kindred_def: Optional[KindredDefinition], gender: str) -> str:
        """Generate a random name for the NPC."""
        # Try to use kindred name tables if available
        if kindred_def and hasattr(kindred_def, "name_tables"):
            try:
                name_table = kindred_def.name_tables
                if gender == "male" and "male" in name_table:
                    first_names = name_table["male"]
                elif gender == "female" and "female" in name_table:
                    first_names = name_table["female"]
                else:
                    first_names = name_table.get("unisex", [])

                surnames = name_table.get("surname", [])

                if first_names:
                    first = DiceRoller.choice(first_names, "NPC first name")
                    if surnames:
                        surname = DiceRoller.choice(surnames, "NPC surname")
                        return f"{first} {surname}"
                    return first
            except Exception:
                pass  # Fall through to generic names

        # Generic fallback names
        male_names = [
            "Aldric",
            "Bertram",
            "Cedric",
            "Dunstan",
            "Edmund",
            "Godwin",
            "Harold",
            "Ivor",
            "Kendrick",
            "Leofric",
            "Marcus",
            "Osric",
            "Radulf",
            "Siward",
            "Wulfric",
        ]
        female_names = [
            "Aelfleda",
            "Beatrice",
            "Cyneburh",
            "Edith",
            "Frideswide",
            "Godgifu",
            "Hild",
            "Isolde",
            "Leofrun",
            "Mildred",
            "Osthryth",
            "Rowena",
            "Sigrid",
            "Thyra",
            "Wulfhild",
        ]
        surnames = [
            "Ashwood",
            "Blackwood",
            "Clayborne",
            "Dunmore",
            "Evergreen",
            "Fernwood",
            "Grimsby",
            "Holloway",
            "Ironside",
            "Thornberry",
        ]

        names = male_names if gender == "male" else female_names
        first = DiceRoller.choice(names, "NPC first name")
        surname = DiceRoller.choice(surnames, "NPC surname")

        return f"{first} {surname}"

    def _apply_extra_data(self, character: CharacterState, extra_data: dict[str, Any]) -> None:
        """Apply extra class-specific data to the character."""
        if not character.class_data:
            character.class_data = ClassSpecificData()

        cd = character.class_data

        # Fighter data
        if "combat_talents" in extra_data:
            cd.combat_talents = list(extra_data["combat_talents"])
        if "slayer_targets" in extra_data:
            cd.slayer_targets = list(extra_data["slayer_targets"])
        if "weapon_specializations" in extra_data:
            cd.weapon_specializations = list(extra_data["weapon_specializations"])

        # Cleric/Friar data
        if "holy_order" in extra_data:
            cd.holy_order = extra_data["holy_order"]

        # Knight data
        if "liege" in extra_data:
            cd.liege = extra_data["liege"]
        if "steed_name" in extra_data:
            cd.steed_name = extra_data["steed_name"]

        # Hunter data
        if "beast_affinity" in extra_data:
            cd.beast_affinity = extra_data["beast_affinity"]

        # Bard data
        if "songs_known" in extra_data:
            cd.songs_known = list(extra_data["songs_known"])

    def get_available_classes(self) -> list[str]:
        """Get list of available character classes."""
        return self.class_manager.get_all_ids()

    def get_available_kindreds(self) -> list[str]:
        """Get list of available kindreds."""
        return self.kindred_manager.get_all_ids()

    def get_classes_for_kindred(self, kindred_id: str) -> list[str]:
        """Get list of classes available to a specific kindred."""
        classes = self.class_manager.get_classes_for_kindred(kindred_id)
        return [c.class_id for c in classes]
